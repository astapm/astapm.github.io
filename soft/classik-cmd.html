<!DOCTYPE html>
<html lang="ru">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="all" />
<meta name="date" content='2015-07-09'>
<meta name="description" content="Это перевод с английского на русский язык руководства «Искусство командной строки» Джошуа Леви об основах работы в командной строке GNU/Linux. Хотя во многом это совместная работа с остальными пользователями GitHub." />
<meta name="keywords" content="Linux, UNIX, shell, командная строка" />
<meta name="author" content="Joshua Levy" />
<meta name="copyright" content="Creative Commons Attribution-ShareAlike 4.0 International" />
<link rel="stylesheet" href="../style.css" type="text/css"/>
<link rel="alternate" type="application/rss+xml" title="Моя RSS-лента" href="https://astapm.github.io/rss.xml" />
<link rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" />
<link rel="canonical" href="https://astapm.github.io/soft/classik-cmd.html" />
<title>
Классика командной строки — Домашняя страница. М. Астапчик 
</title>
</head>
<body>
<header>
<p><a href="../index.html"><strong>Главная</strong></a> | <a href="index.html"><strong>Оглавление книги</strong></a></p>
</header>
<article>
<h1 id="классика-командной-строки">Классика командной строки</h1>
<hr />
<p><em>Это перевод с английского на русский язык руководства «Искусство командной строки» Джошуа Леви (<a href="https://github.com/jlevy">Joshua Levy</a>) об основах работы в командной строке GNU/Linux. Хотя во многом это совместная работа с остальными пользователями GitHub. Лицензия: CC-BY-SA 4.0. Страница на GitHub: <a href="https://github.com/jlevy/the-art-of-command-line" class="uri">https://github.com/jlevy/the-art-of-command-line</a></em></p>
<hr />
<p><strong>От переводчика</strong></p>
<p>Особенность руководства «Искусство командной строки» Джошуа Леви состоит в том, что с одной стороны это всеобъемлющий набор советов для командной строки в GNU/Linux. С другой стороны это руководство достаточно компактное и одностраничное — команды с программами командной строки описаны очень кратко и сжато. Описывается или общий смысл команды или приводится практический пример, позволяющий уяснить эту суть. После чего можно воспользоваться внешними источниками, чтобы глубже разобраться с нужной программой, например, в документации или на других сайтах, посвящённых GNU/Linux.</p>
<figure>
<img src="../fig/soft/serjant.jpg" alt="" /><figcaption>Мне нужна командная строка</figcaption>
</figure>
<p>В некотором роде «Искусство командной строки» Джошуа Леви — это такая панорама, которая изображает целостную картину приёмов и возможностей оболочки командной строки BASH. Именно поэтому свой перевод я назвал «Классика командной строки», а не перевёл название дословно.</p>
<p>Это не дословный перевод руководства «Искусство командной строки» Джошуа Леви. Некоторые места я переводил исходя из общего смысла того или иного предложения. Дословный перевод на русский язык уже имеется на странице руководства на GitHub наравне с переводами на другие языки. К тому же само руководство будет ещё совершенствоваться и дополняться. Я же оставлю вариант перевода на июль 2015 года, потому что он вполне самодостаточный.</p>
<p><em>Астапчик Михаил, 2015</em></p>
<h2 id="содержание-и-введение">Содержание и введение</h2>
<ul>
<li><a href="#описание">Описание</a></li>
<li><a href="#основы">Основы</a></li>
<li><a href="#повседневное-использование">Ежедневное использование</a></li>
<li><a href="#обработка-файлов-и-данных">Обработка файлов и данных</a></li>
<li><a href="#отладка-системы">Отладка системы</a></li>
<li><a href="#однострочники">Однострочники</a></li>
<li><a href="#неприметные-но-полезные">Неприметные, но полезные</a></li>
<li><a href="#другие-источники">Другие источники</a></li>
<li><a href="#отказ-от-ответственности">Отказ от ответственности</a></li>
<li><a href="#лицензия">Лицензия</a></li>
</ul>
<figure>
<img src="../fig/soft/cowsay.png" alt="" /><figcaption>Рис. curl -s ‘https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md’ | egrep -o ‘<code>\w+</code>’ | tr -d ‘`’ | cowsay -W50</figcaption>
</figure>
<p>К умению свободно владеть командной строкой часто относятся пренебрежительно или считают это чем-то вроде магии. Но это умение явно и неявно увеличивает возможности и производительность работы любого инженера. Перед вами подборка примечаний и подсказок для командной строки, которую я считаю полезной, работая в GNU/Linux. Некоторые подсказки элементарны, некоторые довольно специфичны, есть среди них изящные и даже замысловатые. Эта небольшая по объёму подборка советов, но если Вы умеете использовать и помните все пункты этого руководства, значит Вы знаете много.</p>
<p>Многое из написанного ниже <a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">первоначально</a> <a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">появились</a> на сервисе <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>, но, учитывая тамошний интерес, думаю, что правильно будет использовать сервис Github, где люди более талантливы, чем я, и могут с готовностью предложить лучшие варианты. Если вы увидели ошибку или что-то, что может быть улучшено, то, пожалуйста, отправьте запрос. (Конечно, пожалуйста, сначала ознакомьтесь с уже существующими вопросами.)</p>
<p><a href="https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge">Join the chat at https://gitter.im/jlevy/the-art-of-command-line</a></p>
<h2 id="описание">Описание</h2>
<p><em>Область применения:</em></p>
<ul>
<li><p>Это руководство предназначено как для начинающих, так и для опытных пользователей GNU/Linux. Цели руководства: обширность (все самое важное), специфичность (дать конкретные примеры общих случаев), и краткость (избегать несущественных вещей или нюансов, которые вы можете легко найти в другом месте). Каждый совет руководства имеет важное значение в какой-то конкретной ситуации или значительно экономит время по сравнению с альтернативными решениями.</p></li>
<li><p>Это руководство написано для GNU/Linux. Многие, но не все пункты данного руководства в равной степени относятся к MacOS (или даже Cygwin).</p></li>
<li><p>Акцент делается на интерактивную командную оболочку Bash, хотя многие советы относятся и к скриптам (сценариям) Bash, а также применимы к другим командным оболочкам.</p></li>
<li><p>Руководство включает в себя как стандартные Unix-команды, так и те, которые требуют отдельной установки — потому что они достаточно важны и заслуживают упоминания.</p></li>
</ul>
<p><em>Примечания:</em></p>
<ul>
<li><p>Чтобы компактно уместить советы на одной странице, содержание явно или неявно содержит или предполагает ссылку. Вы достаточно сообразительны, чтобы найти более подробную информацию в другом месте, например в Google, когда вы знаете идею или команду. Используйте также <code>apt-get</code> / <code>yum</code> / <code>dnf</code> / <code>pacman</code> / <code>pip</code> / <code>brew</code> (при необходимости), чтобы установить новые программы.</p></li>
<li><p>Используйте сервис <a href="http://explainshell.com">Explainshell</a>, если владеете английским языком, чтобы получить полный разбор команды и её опций.</p></li>
</ul>
<h2 id="основы">Основы</h2>
<p>Изучите командную оболочку Bash. По крайней мере, просто наберите в терминале команду <code>man bash</code> и просмотрите вывод; это довольно легко и не займёт много времени. Альтернативные оболочки командной строки могут быть более заманчивы для изучения, но Bash является мощным инструментом, который всегда доступен (изучение только zsh, fish и т.д. может быть заманчивым, например, для работы на ноутбуке, но ограничит вас во многих других ситуациях — например, при работе с сервером).</p>
<p>Для русскоязычных небольшое примечание. В зависимости от дистрибутива страницы <code>man</code> могут быть на английском языке. Можно в таком случае попробовать стандартную опцию <code>--help</code> для встроенной справки о программе. Стандартная справка команды может оказаться на русском языке.</p>
<p>Изучите, по крайней мере, также один текстовый редактор для редактирования текстовых файлов в терминале. В идеале это Vim (vi), даже если вы предпочитаете Emacs, мощный IDE или современный хипстерский редактор кода.</p>
<p>Научитесь читать документацию с использованием команды справочных страниц <code>man</code>. Для любознательных, команда <code>man man</code> перечисляет номера разделов справки. Например, раздел 1 — это справка по исполняемым программам или командам оболочки (shell); раздел 5 — это форматы файлов и соглашения, например о /etc/passwd; раздел 8 — это справка о командах для администрирования системы). Находите в справке нужные команды по ключевым словам с помощью <code>apropos</code>. Узнайте, какие команды включены в состав оболочки — напишите <code>help</code> или <code>help -d</code> чтобы увидеть этот список.</p>
<p>Узнайте о перенаправлении вывода и ввода процессов с помощью <code>&gt;</code> и <code>&lt;</code> и о канале взаимодействия между процессами pipe (конвейере) с использованием символа <code>|</code>. Помните, что <code>&gt;</code> — переписывает файл, а <code>&gt;&gt;</code> добавляет к файлу. Узнайте о стандартном выводе и стандартном потоке ошибок (stderr).</p>
<p>Выучите подстановочные символы, позволяющие задавать несколько имен команд или файлов в одном выражении: <code>*</code>, <code>?</code> и <code>{ … }</code>. Уясните использование в командной строке кавычек и разницу между двойными и одинарными кавычками.</p>
<p>Ознакомитесь с управлением процессами в Bash с помощью: <code>&amp;</code>, <strong>Ctrl-Z</strong>, <strong>Ctrl-C</strong>, <code>jobs</code>, <code>fg</code>, <code>bg</code>, <code>kill</code> и т.д.</p>
<p>Изучите <code>ssh</code>, изучите основы беспарольной аутентификации через <code>ssh-agent</code>, <code>ssh-add</code> и т.д.</p>
<p>Изучите основы управления файлами: <code>ls</code> и <code>ls -l</code> (в частности, узнайте, что означает каждый столбец в <code>ls -l</code>), <code>less</code>, <code>head</code>, <code>tail</code> и <code>tail -f</code> (или даже лучше, <code>less +F</code>), <code>ln</code> и <code>ln -s</code> (узнать различия и преимущества жёстких и мягких ссылок), <code>chown</code>, <code>chmod</code>, <code>du</code> (для быстрого просмотра использования диска: <code>du -hk *</code>). Для управления файловой системой: <code>df</code>, <code>mount</code>, <code>fdisk</code>, <code>mkfs</code>, <code>lsblk</code>.</p>
<p>Не забудьте про основы управления сетью: <code>ip</code> или <code>ifconfig</code>, <code>dig</code>.</p>
<p>Разберитесь хорошо с регулярными выражениями, а также с различными флагами <code>grep</code> / <code>egrep</code>. Опции <code>-i</code> , <code>-o</code> , <code>-A</code> , и <code>-B</code> стоит хорошо изучить.</p>
<p>Выучите использование менеджеров пакетов <code>apt-get</code>, <code>yum</code>, <code>dnf</code> или <code>pacman</code> (в зависимости от дистрибутива), чтобы найти и установить программы. И убедитесь, что у вас есть <code>pip</code>, чтобы установить утилиты и программные пакеты, написанные на Python.</p>
<h2 id="повседневное-использование">Повседневное использование</h2>
<p>В Bash, используйте <strong>Tab</strong>, чтобы завершить команды и аргументы и <strong>Ctrl-R</strong> для поиска по истории команд.</p>
<p>При наборе в командной строке Bash используйте <strong>Ctrl-W</strong>, чтобы удалить последнее слово, и <strong>Ctrl-U</strong>, чтобы удалить всю набранную до самого начала строку. Используйте <strong>Alt-B</strong> и <strong>Alt-F</strong>, чтобы перейти от слова к слову, <strong>Ctrl-K</strong>, чтобы удалить слова в конце строки, <strong>Ctrl-L</strong>, чтобы очистить экран. Смотри <code>man readline</code> для комбинаций всех клавиш по умолчанию в Bash.</p>
<p>Кроме того, если вы любите работу в vi-подобном режиме, то команды редактирования в командной строке могут быть установлены в этот режим с помощью <code>set -o vi</code>.</p>
<p>Чтобы увидеть последние команды, используйте <code>history</code>. Есть также много сокращений, как, например, <code>!$</code> (последний аргумент) и <code>!!</code> (последняя команда), хотя их часто легко заменить на <strong>Ctrl-R</strong> и <strong>Alt-.</strong>.</p>
<p>Чтобы вернуться к предыдущему рабочему каталогу: <code>cd -</code></p>
<p>Если вы во время набора команды вы передумали её вводить, нажмите <strong>Alt-#</strong> — в начале команды будет добавлено <code>#</code> и введите команду в качестве комментария (или используйте сочетание клавиш: <strong>Ctrl-а</strong>, <strong>#</strong>, <strong>Ввод</strong>). Вы можете вернуться к ней позже с помощью истории команд.</p>
<p>Используйте мощную утилиту <code>xargs</code> (или <code>parallel</code>). Запомните, в <code>xargs</code>вы можете установить число непустых строк аргументов, прочитанных со стандартного ввода (<code>-L</code>), а также распараллелить процессы (<code>-P</code>). Если вы не уверены в том, что команда будет делать то, что нужно, используйте сначала <code>xargs echo</code>. Кроме того удобна опция <code>-I{}</code>. Примеры:</p>
<pre><code>find . -name ’*.py’ | xargs grep some_function
cat hosts | xargs -I{} ssh root@{} hostname</code></pre>
<p>Команда <code>pstree -p</code> полезна для просмотра дерева процессов.</p>
<p>Используйте <code>pgrep</code> и <code>pkill</code>, чтобы найти процесс или послать сигнал процессу по имени и другим атрибутам (опцию <code>-f</code> полезно использовать).</p>
<p>Узнайте, какие различные сигналы можно передавать процессам. Например, чтобы приостановить процесс, используйте <code>kill -STOP [pid]</code>. Полный список сигналов смотри командой <code>man 7 signal</code>.</p>
<p>Используйте <code>nohup</code> или <code>disown</code>, которые запускают указанную команду как невосприимчивую к сигналам завершения, и чей вывод будет не направлен на терминал. Таким образом, команда будет продолжать выполняться в фоновом режиме и после того, как пользователь выйдет из системы.</p>
<p>Проверьте, какие процессы прослушивают сеть, с помощью <code>netstat -lntp</code> или <code>ss -plat</code> (для TCP, опция <code>-u</code> для UDP).</p>
<p>Смотрите также <code>lsof</code> для вывода информации о том, какие файлы и сокеты используются теми или иными процессами.</p>
<p>В сценариях Bash используйте <code>set -x</code> для установки режима отладки вывода. По возможности используйте строгие режимы отладки. Используйте <code>set -e</code> для остановки скрипта на ошибках. Используйте <code>set -o pipefail</code> также, чтобы увидеть ошибки в коде, переменных и «пайпах» (хотя эта тема более тонкая). Для более сложных сценариев используйте <code>trap</code>.</p>
<p>В сценариях Bash используйте подоболочки (Subshells), которые записываются в скобках, для группы команд. Типичным примером является временный переход в другую рабочую директорию, например:</p>
<pre><code># Сделать что-то в текущей директории
(cd /some/other/dir &amp;&amp; другие команды)
# Продолжать в оригинальном режиме</code></pre>
<p>Обратите внимание, в Bash есть много видов определения переменных. Проверка существования переменной: <code>${name:?error message}</code>. Например, если сценарий Bash требует один аргумент, просто напишите <code>input_file=${1:?usage: $0 input_file}</code>. Арифметическое определение: <code>i=$(( (i + 1) % 5 ))</code>. Последовательности: <code>{1..10}</code>. Обрезка строк: <code>${var%suffix}</code> и <code>echo ${var%.pdf}.txt</code>. Например, если <code>var=foo.pdf</code>, то echo <code>echo ${var%.pdf}.txt</code> печатает <code>foo.txt</code>.</p>
<p>Если использовать <code>&lt;(команда)</code>, то вывод из команды может рассматриваться как файл. Сравним, например, локальный файл <code>/etc/hosts</code> с файлом на внешнем компьютере:</p>
<pre><code>diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</code></pre>
<p>Разберитесь с синтаксисом встроенных документов <code>Heredoc</code> (дословно с английского «здесь документ») в командной строке Bash, как, например, <code>cat &lt;&lt;EOF …</code>. Встроенные документы полезны для внедрения больших блоков текстовых данных в скрипт. Когда интерпретатор встречает подобную конструкцию, он направляет строки вплоть до указанного маркера (в данном случае — EOF) на входной поток команды.</p>
<p>В Bash соединение стандартного вывода и вывода сообщений об ошибках может быть таким образом: <code>some-command &gt;logfile 2&gt;&amp;1</code>. Чтобы команда не оставила открытым файл, привязав его к открытому терминалу, считается хорошей практикой добавлять <code>&lt;/dev/null</code>.</p>
<p>Используйте <code>man ascii</code> с замечательными таблицами ASCII, где указаны шестнадцатеричные и десятичные значения символов. Для получения общей информации о кодировках: <code>man unicode</code>, <code>man utf—8</code>, и <code>man latin1</code>.</p>
<p>Используйте <code>screen</code> или <code>tmux</code> для мультиплексирования терминала, что особенно полезно для удаленных сессий SSH, потому что даёт возможность отключать виртуальные сеансы от управляющего терминала, а потом подключить снова. Более простая альтернатива для удаленных сессий, которые возможно прервать и подключиться вновь, это только <code>dtach</code>.</p>
<p>Узнайте, как в SSH пробросить порты в туннель с помощью опций <code>-L</code> или <code>-D</code> (а иногда и -R ), например, для доступа к веб-сайту с удаленного сервера.</p>
<p>Могут быть полезными несколько оптимизаций в конфигурации SSH; например, <code>~/.ssh/config</code> содержит настройки, позволяющие избежать разрыва подключений в некоторых сетевых средах, использовать сжатие (что полезно при копировании <code>scp</code> на соединениях с низкой пропускной способностью), создать мультиплексирование каналов на один сервер:</p>
<pre><code>TCPKeepAlive=yes
ServerAliveInterval=15
ServerAliveCountMax=6
Compression=yes
ControlMaster auto
ControlPath /tmp/%r@%h:%p
ControlPersist yes</code></pre>
<p>Другие варианты настроек SSH чувствительны безопасности, и должны включаться с осторожностью, например: <code>StrictHostKeyChecking=no</code>, <code>ForwardAgent=yes</code>.</p>
<p>Чтобы получить разрешения на доступ к файлу в восьмеричной форме, что не доступно в ls, и что бывает нужно для настройки системы, нужно использовать что-то вроде</p>
<pre><code>stat -c ’%A %a %n’ /etc/timezone</code></pre>
<p>Для интерактивного выбора значений из вывода другой команды, используйте <a href="https://github.com/mooz/percol"><code>percol</code></a> или <a href="https://github.com/junegunn/fzf"><code>fzf</code></a>.</p>
<p>Для взаимодействия с файлами на основании выходного списка другой команды (например, <code>git</code> ), используйте <code>fpp</code> (<a href="https://github.com/facebook/PathPicker">PathPicker</a>).</p>
<p>Для простого веб-сервера для всех файлов в текущем каталоге (и подкаталогах), доступных для всех, кто в сети, используйте: <code>python -m SimpleHTTPServer 7777</code> (для порта 7777 и Python 2) и <code>python -m http.server 7777</code> (для порта 7777 и Python 3).</p>
<p>Чтобы выполнить определенную команду с привилегиями суперпользователя, используйте <code>sudo</code> и <code>sudo -u</code> для выполнения команды с привилегиями другого пользователя.</p>
<h2 id="обработка-файлов-и-данных">Обработка файлов и данных</h2>
<p>Чтобы найти файл по имени в текущем каталоге используйте подобное <code>find . -iname ’*something*’</code>. Чтобы найти файл в любом месте системы, используйте <code>locate что-нибудь</code> (но имейте в виду, <code>updatedb</code>, возможно, ещё не проиндексировал недавно созданные файлы).</p>
<p>Для общего поиска в исходниках или файлах данных (более продвинутого, чем <code>grep -r</code>), используйте <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a>.</p>
<p>Для преобразования HTML в текст: <code>lynx -dump -stdin</code>.</p>
<p>Для Markdown, HTML и всех видов преобразования документов, попробуйте <a href="http://pandoc.org"><code>pandoc</code></a>.</p>
<p>Если необходимо обработать XML, используйте старый добрый <code>xmlstarlet</code>.</p>
<p>Для JSON используйте <code>jq</code>.</p>
<p>Для Excel или CSV файлов, <a href="https://github.com/onyxfish/csvkit"><code>csvkit</code></a> предоставляет набор инструментов: <code>in2csv</code>, <code>csvcut</code>, <code>csvjoin</code>, <code>csvgrep</code> и т.д.</p>
<p>Для Amazon S3 <a href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> удобнее, а <a href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> быстрее. Для остальных сервисов Амазона используйте стандартный <a href="https://github.com/aws/aws-cli"><code>aws</code></a>.</p>
<p>Нужно иметь представление об утилитах сортировки <code>sort</code> и <code>uniq</code>. Для Uniq — опции <code>-u</code> и <code>-d</code>. Рассмотрите также утилиту сравнения строк в файле <code>comm</code>.</p>
<p>Требуется знать о <code>cut</code> , <code>paste</code> и <code>join</code> для манипулирования текстовыми файлами. Многие люди используют <code>cut</code>, но забывают о <code>join</code>.</p>
<p>Нужно знать об утилите статистики текстового файла <code>wc</code>, и уметь выводить количество строк (<code>-l</code>), символов (<code>-m</code>), слов (<code>-w</code>) и байтов (<code>-c</code>).</p>
<p>Нужно знать о <code>tee</code> для копирования из стандартного ввода в файл или на стандартный вывод, как, например, <code>ls -al | tee file.txt</code>.</p>
<p>Знайте, что языковая «локаль» (locale) влияет на множество инструментов командной строки не очевидным образом, в том числе — и на порядок сортировки и производительность. В большинстве инсталляций Linux будут установлены языковые параметры <code>LANG</code> автоматически. Но имейте в виду, параметры сортировки изменятся, если вы измените локаль. Учитывайте, что функции интернационализации <code>i18n</code> могут сделать выполнение сортировки или каких-либо других команд значительно медленнее. В некоторых ситуациях вы можете спокойно игнорировать медленные процедуры <code>i18n</code> и использовать традиционный байт-ориентированный порядок сортировки, используя <code>export LC_ALL=C</code>.</p>
<p>Знайте основы <code>awk</code> и <code>sed</code>. Например, суммирование все чисел в третьей колонке текстового файла: <code>awk ’{ x += $3 } END { print x }’</code>. Это, вероятно, в три раза быстрее и в три раза короче эквивалентной программы на Python.</p>
<p>Заменить все вхождения строки, в одном или нескольких файлах:</p>
<pre><code>perl -pi.bak -e ’s/old-string/new-string/g’ my-files-*.txt</code></pre>
<p>Чтобы переименовать много файлов за один раз в соответствии с паттерном, используйте <code>rename</code>. Для сложных переименований может помочь <a href="https://github.com/jlevy/repren"><code>repren</code></a>.</p>
<pre><code># Восстановление файлов резервной копии foo.bak -&gt; foo:
rename ’s/\.bak$//’ *.bak

# Полное переименование имен файлов, каталогов и содержимого foo -&gt; bar:
repren --full --preserve-case --from foo --to bar .</code></pre>
<p>Используйте <code>shuf</code>, чтобы перетасовать или выбрать случайные строки из файла.</p>
<p>Хорошо разберитесь с опциями замечательной утилиты <code>sort</code> для сортировки в алфавитном или нумерологическом порядке строк текста, разделённых на поля, колонки и т.д. Для нумерологической сортировки используйте опции <code>-n</code> . Узнайте, как работают ключи (<code>-t</code> и <code>-k</code>). В частности, обратите внимание, в каких случаях нужно ставить точку в числовых параметрах опции <code>-k</code>, а в каких — запятую. Опция пересортировки <code>-s</code> может быть полезной. Например, для сортировки сначала по полю 2, а потом уже по полю 1 можно использовать <code>sort -k1,1 | sort -s -k2,2</code>. Используйте опцию <code>-h</code> для представления вывода чисел команды <code>sort</code> в удобочитаемом виде (наподобие <code>du -h</code>)</p>
<p>Если вы когда-нибудь понадобится написать знак табуляции в командной строке (например, как аргумент опции -t для сортировки), нажмите <strong>ctrl-v</strong> <strong>[Tab]</strong> или наберите <code>$’\t’</code> (последнее лучше, так как вы можете скопировать/вставьте это).</p>
<p>Стандартные инструменты для патча исходного кода <code>diff</code> и <code>patch</code>. Посмотрите также <code>diffstat</code> для краткой статистики <code>diff</code>. Примечание: <code>diff -r</code> работает для целых каталогов. Используйте <code>diff -r tree1 tree2 | diffstat</code> для описания изменений.</p>
<p>Для бинарных файлов, используйте <code>hd</code> для просмотра шестнадцатеричных дампов и <code>bvi</code> для бинарного редактирования.</p>
<p>Кроме того в бинарных файлах <code>strings</code> (плюс <code>grep</code> и т.д.) позволяет найти кусочки текста.</p>
<p>Построить разницу между двумя бинарными файлами (дельта-разница) позволяет <code>xdelta3</code>.</p>
<p>Для преобразования текстовых кодировок попробуйте <code>iconv</code>. Или <code>uconv</code> для более сложных случаев; он поддерживает некоторые дополнительные вещи Unicode. Например, команда ниже переводит строки в нижний регистр и удаляет все акценты:</p>
<pre><code>uconv -f utf—8 -t utf—8 -x ’::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; ’ &lt; input.txt &gt; output.txt</code></pre>
<p>Чтобы разделить файлы на куски, смотрите <code>split</code> (разделить по размеру) и <code>csplit</code> (разделить шаблоном).</p>
<p>Используйте <code>zless</code>, <code>zmore</code>, <code>zcat</code> и <code>zgrep</code> для работы с сжатыми файлами.</p>
<h2 id="отладка-системы">Отладка системы</h2>
<p>Для веб-отладки <code>curl</code> и <code>curl -I</code>, или <code>wget</code> как эквивалент, или более современной <a href="https://github.com/jakubroztocil/httpie"><code>httpie</code></a>.</p>
<p>Чтобы узнать статус диска, CPU, состояния сети, используйте <code>iostat</code>, <code>netstat</code>, <code>top</code> (или лучше <code>htop</code>), и (особенно) <code>dstat</code>. Хорошо для быстрого получения информации о том, что происходит в системе.</p>
<p>Для более детального обзора системы используйте <a href="https://github.com/nicolargo/glances"><code>glances</code></a>. Программа представит вам несколько уровней статистики системы в одном окне терминала. Очень полезно для быстрой проверки нескольких систем.</p>
<p>Чтобы узнать состояние памяти, нужно запускать и понять вывод <code>free</code> и <code>vmstat</code>. В частности, будьте в курсе "cached" — это данные в памяти, которые загружены с жесткого диска и используется для супербыстрого к ним доступа, а по сути, эта кэшированная память свободна.</p>
<p>Отладка системы Java — это отдельный вопрос. Но есть простой трюк для JVM Oracle и некоторых других виртуальных машин Java: вы можете запустить <code>kill —3 &lt;pid&gt;</code> и получить трассировку стека и данные heap-памяти (в том числе детализацию сборщика мусора, которая может быть весьма информативна) в стандартный поток ошибок или логи.</p>
<p>Используйте <code>mtr</code> как лучший трассировщик, чтобы определить проблемы с сетью.</p>
<p>Для просмотра того, чем заполнен диск, используйте <code>ncdu</code>, который экономит время на обычных командах, таких как <code>du -sh *</code>.</p>
<p>Чтобы обнаружить, какой разъем или процесс использует полосу пропускания, попробуйте <code>iftop</code> или <code>nethogs</code>.</p>
<p>Инструмент <code>ab</code> (поставляется с Apache) является полезным для быстрой и черновой проверки производительности веб-сервера. Для более сложных испытаний под нагрузкой, попробуйте <code>siege</code>.</p>
<p>Для более серьезной отладки сети: <code>wireshark</code>, <code>tshark</code> или <code>ngrep</code>.</p>
<p>Необходимо знать о <code>strace</code> и <code>ltrace</code>. Это может быть полезно, если программа не запускается, или произошло зависание или сбой, и вы не знаете почему. Или вы хотите получить общее представление о производительности программы. Обратите внимание на опцию профилирования ( <code>-c</code> ) и возможность подключаться к работающему процессу ( <code>-p</code> ).</p>
<p>Помните о <code>ldd</code>, чтобы проверять разделяемые библиотеки и т.д.</p>
<p>Умейте подключаться к запущенному процессу с помощью <code>gdb</code> и получить отладочную информацию.</p>
<p>Используйте <code>/proc</code>. Это удивительно полезно иногда при отладке живых проблемы. Примеры: <code>/proc/cpuinfo</code>, <code>/proc/xxx/cwd</code>, <code>/proc/xxx/exe</code>, <code>/proc/xxx/fd/</code>, <code>/proc/xxx/smaps</code>.</p>
<p>При отладке, если что-то пошло не так, <code>sar</code> может быть полезной. Она показывает историю статистических данных о CPU, памяти, сети, и т.д.</p>
<p>Для более глубокого анализа систем и производительности анализирует посмотрите в сторону <code>stap</code> (<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>), <a href="http://en.wikipedia.org/wiki/Perf_(Linux)"><code>perf</code></a> и <a href="https://github.com/draios/sysdig"><code>sysdig</code></a>.</p>
<p>Удостоверьтесь, с каким дистрибутивом вы работаете: <code>lsb_release -a</code></p>
<p>Используйте <code>dmesg</code> для просмотра вывода буфера сообщений ядра. Это может помочь при проблемах аппаратного обеспечения или драйвера.</p>
<h2 id="однострочники">Однострочники</h2>
<p>Объединим всё в одно.</p>
<p>Полезно иногда сделать пересечение, объединение или разность текстовых файлов с помощью <code>sort</code> / <code>uniq</code>. Предположим, a и b — текстовые файлы, которые различны. Этот однострочник быстр, и работает с файлами произвольного размера, вплоть до многих гигабайт. (Сортировка не ограничивается размером памяти, хотя, возможно, потребуется использовать опцию <code>-T</code> , если <code>/tmp</code> находится на маленьком корневом разделе.) Смотри также выше примечание о <code>LC_ALL</code> и <code>sort</code> с опцией <code>-u</code>.</p>
<pre><code>cat a b | sort | uniq &gt; c # c — это объединение a и b
cat a b | sort | uniq -d &gt; c # c — это пересечение a и b
cat a b b | sort | uniq -u &gt; c # c — это разница a и b</code></pre>
<p>Используйте <code>grep . *</code>, чтобы визуально изучить все содержимое всех файлов в каталоге — например, каталоги, заполненных файлами конфигурации <code>/sys</code>, <code>/proc</code>, <code>/etc</code>.</p>
<p>Суммирование всех чисел в третьей колонке текстового файла. Это, вероятно, в три раза быстрее и в три раза короче эквивалентной программы на Python.</p>
<pre><code>awk ’{ x += $3 } END { print x }’ myfile</code></pre>
<p>Однострочник, если нужно увидеть размер и даты на дереве файлов. Это как рекурсивный <code>ls -l</code> , но более читабельный, чем <code>ls -lR</code>:</p>
<pre><code>find . -type f -ls</code></pre>
<p>Используйте мощную утилиту <code>xargs</code> (или <code>parallel</code>). Примечание, в <code>xargs</code>вы можете установить число непустых строк аргументов, прочитанных со стандартного ввода (<code>-L</code>), а также распараллелить процессы (<code>-P</code>). Если вы не уверены, что команда будет делать то, что нужно, используйте сначала <code>xargs echo</code>. Кроме того удобна опция <code>-I{}</code>. Примеры:</p>
<pre><code>find . -name ’*.py’ | xargs grep some_function
cat hosts | xargs -I{} ssh root@{} hostname</code></pre>
<p>Скажем, у вас есть текстовый файл, как, например, журнал веб-сервера, и нужны строки со значением, например, <code>acct_id</code>. Если вы хотите подсчитать, сколько запросов для каждого acct_id:</p>
<pre><code>cat access.log | egrep -o ’acct_id=[0—9]+’ | cut -d= -f2 | sort | uniq -c | sort -rn</code></pre>
<p>Запустите эту функцию, чтобы получить случайный совет из этого документа (разбирает Markdown и извлекает элемент):</p>
<pre><code>function taocl() {
curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |
pandoc -f markdown -t html |
xmlstarlet fo --html --dropdtd |
xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; |
xmlstarlet unesc | fmt —80
}</code></pre>
<h2 id="неприметные-но-полезные">Неприметные, но полезные</h2>
<ul>
<li><p><code>expr</code>: выполняет арифметические, логические операции и регулярные выражения;</p></li>
<li><p><code>m4</code>: простой Макропроцессор;</p></li>
<li><p><code>yes</code>: многократный вывод строки;</p></li>
<li><p><code>cal</code>: красивый календарь;</p></li>
<li><p><code>env</code>: выполнить команду (используется в сценариях);</p></li>
<li><p><code>printenv</code>: распечатать переменные среды (в целях отладки и скриптов);</p></li>
<li><p><code>look</code>: поиск слова (или абзаца в файле), начинающегося заданной строкой;</p></li>
<li><p><code>cut</code> и <code>paste</code> и <code>join</code>: манипулирование данными;</p></li>
<li><p><code>fmt</code>: переформатирует каждый абзац в файле(ах);</p></li>
<li><p><code>pr</code>: простое форматирование файлов, отправляемых на принтер;</p></li>
<li><p><code>fold</code>: перенос строк текста в текстовом файле;</p></li>
<li><p><code>column</code>: форматирование ввода в несколько колонок;</p></li>
<li><p><code>expand</code> и <code>unexpand</code>: конвертировать табуляции и пробелов;</p></li>
<li><p><code>nl</code>: добавить номера строк;</p></li>
<li><p><code>seq</code>: вывод последовательности чисел;</p></li>
<li><p><code>bc</code>: калькулятор;</p></li>
<li><p><code>factor</code>: разложение целого числа на простые множители;</p></li>
<li><p><code>gpg</code>: шифровать и подписывать файлы;</p></li>
<li><p><code>toe</code>: таблица записей TERMINFO;</p></li>
<li><p><code>nc</code>: устанавливать соединения TCP и UDP, принимать оттуда данные и передавать их;</p></li>
<li><p><code>socat</code>: ретранслятор для двунаправленной передачи данных между двумя независимыми каналами (по аналогии с netcat);</p></li>
<li><p><code>slurm</code>: визуализация сетевого трафика;</p></li>
<li><p><code>dd</code>: перемещение данных между файлами или устройствами</p></li>
<li><p><code>file</code>: определить тип файла</p></li>
<li><p><code>tree</code>: древовидное отображение каталогов и подкаталогов;</p></li>
<li><p><code>stat</code>: информация о файле;</p></li>
<li><p><code>tac</code>: печать файлов, начиная с последней строки;</p></li>
<li><p><code>shuf</code>: случайный выбор строк из файла;</p></li>
<li><p><code>comm</code>: Сравнивает сортированные файлы построчно;</p></li>
<li><p><code>pv</code>: просмотрщик «пайпов», показывает скорость обработки данных через «пайп»;</p></li>
<li><p><code>hd</code> и <code>bvi</code>: дамп и редактирование двоичных файлов;</p></li>
<li><p><code>strings</code>: извлечения текста из бинарных файлов;</p></li>
<li><p><code>tr</code>: манипулирование символами со стандартного ввода;</p></li>
<li><p><code>iconv</code> или <code>uconv</code>: преобразование кодировок;</p></li>
<li><p><code>split</code> и <code>csplit</code>: разделение файлов;</p></li>
<li><p><code>units</code>: преобразования и рассчёты единиц измерения; (см. также /usr/share/units/definitions.units);</p></li>
<li><p><code>7z</code>: сжатие файлов;</p></li>
<li><p><code>ldd</code>: информация о динамических библиотеках;</p></li>
<li><p><code>nm</code>: информацию о бинарных файлах (объектных файлах, библиотеках, исполняемых файлах и т.д.);</p></li>
<li><p><code>ab</code>: бенчмарк веб-серверов;</p></li>
<li><p><code>strace</code>: отслеживает системные вызовы между процессом и операционной системой (ядром).</p></li>
<li><p><code>mtr</code>: лучший трассировщик для отладки сети;</p></li>
<li><p><code>cssh</code>: одновременное выполнение команд и внесения изменений в файлы конфигурации на нескольких хостах;</p></li>
<li><p><code>rsync</code>: синхронизация файлов и папок через SSH;</p></li>
<li><p><code>wireshark</code> и <code>tshark</code>: пакет для захвата и анализа сетевого трафика;</p></li>
<li><p><code>ngrep</code>: grep для сетевого слоя;</p></li>
<li><p><code>host</code> и <code>dig</code>: DNS-запросы;</p></li>
<li><p><code>lsof</code>: информации о том, какие файлы используются теми или иными процессами;</p></li>
<li><p><code>dstat</code> : полезная статистика о системе;</p></li>
<li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>: высокий уровень, обзор нескольких подсистема;</p></li>
<li><p><code>iostat</code>: статистика использования CPU и дисков;</p></li>
<li><p><code>htop</code>: улучшенная версия top;</p></li>
<li><p><code>last</code>: история логинов;</p></li>
<li><p><code>w</code>: кто вошёл в систему;</p></li>
<li><p><code>id</code>: информация о пользователе id/группа;</p></li>
<li><p><code>sar</code>: периодическая статистика системы;</p></li>
<li><p><code>iftop</code> или <code>nethogs</code>: кто в данный момент нагружает сетевой канал;</p></li>
<li><p><code>ss</code>: для исследования сокетов;</p></li>
<li><p><code>dmesg</code>: сообщения об ошибках загрузки и системы;</p></li>
<li><p><code>hdparm</code>: для регулировки и просмотра параметров жёстких дисков с интерфейсом SATA/ATA;</p></li>
<li><p><code>lsb_release</code>: информация о дистрибутиве Linux;</p></li>
<li><p><code>lsblk</code>: Список блочных устройств: древовидное представление дисков и дисковых разделов;</p></li>
<li><p><code>lshw</code>, <code>lscpu</code>, <code>lspci</code>, <code>lsusb</code>, <code>dmidecode</code>: информация об аппаратном обеспечении, в том числе процессоре, BIOS, RAID, графике, устройствах и т.д.;</p></li>
<li><p><code>fortune</code>, <code>ddate</code> и <code>sl</code>: гм, ну, эти паравозики и прочие может быть тоже кому-нибудь будут «полезны».</p></li>
</ul>
<h2 id="другие-источники">Другие источники</h2>
<p><a href="https://github.com/alebcay/awesome-shell">Удивительные оболочки</a>: Дополняемый список инструментов и ресурсов для командной строки.</p>
<p><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Strict mode</a>: Для перфекционистов.</p>
<h2 id="отказ-от-ответственности">[Отказ от ответственности</h2>
<p>За исключением некоторого, код написан так, что другие могут прочитать его. С силой приходит ответственность. То, что вы можете сделать что-то в Bash, не обязательно означает, что вы это должны делать! ;)</p>
<h2 id="лицензия">Лицензия</h2>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"></a></p>
<figure>
<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="" /><figcaption>Рис. Creative Commons License</figcaption>
</figure>
<p>Эта работа распространяется по лицензии <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<time>2015-07-09</time>
</article>
<footer>
<hr />
<p>2020-2022. CC Zero. Астапчик Михаил amblrs@mail.ru. I'm hosted with GitHub Pages.</p>
</footer>
</body>
</html>
